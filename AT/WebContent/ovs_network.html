<!-- Loads and initializes the library -->
<script type="text/javascript">
 var mxBasePath = "mxgraph";
</script>
<script type="text/javascript" src="mxgraph/js/mxClient.js"></script>

<script type="text/javascript">
		// Program starts here. Creates a sample graph in the
		// DOM node with the specified ID. This function is invoked
		// from the onLoad event handler of the document (see below).
		
		var graph;
		var keyHandler;
		var focusedCell;
		
		function main(container)
		{
			// Checks if the browser is supported
			if (!mxClient.isBrowserSupported())
			{
				// Displays an error message if the browser is not supported.
				mxUtils.error('Browser is not supported!', 200, false);
			}
			else
			{	
				var xml;
				// Disables the built-in context menu
				mxEvent.disableContextMenu(container);
				// Creates the graph inside the given container
				graph = new mxGraph(container);
				graph.setCellsResizable(false);
				graph.setAllowDanglingEdges(false);
				graph.setConnectable(true);
				//graph.setHtmlLabels(true);
				graph.setResizeContainer(true);
				graph.minimumContainerSize = new mxRectangle(0, 0, 500, 380);
				graph.setBorder(60);
				
				//disables editing of labels
				graph.isCellEditable = function(cell){
					return false;
				};
				
				//disables replication of edges
				graph.multigraph = false;
				
				//this sets the label to the dpid
				graph.convertValueToString = function(cell){
					if (mxUtils.isNode(cell.value)){
						if (cell.value.nodeName.toLowerCase() == ('switch')){
							return cell.getAttribute('dpid');
						}
					}
					
					return ''; //returning empty string for edges and other stuff
				};
				
				/*graph.addListener(mxEvent.CELLS_ADDED, function(sender, evt) {
			    
					var vertex = evt.getProperties().cells[0];
			    	if(vertex.isVertex()){
			    		var label = graph.getLabel(vertex);
			    		var geometry= graph.getModel().getGeometry(vertex);
			    		var fontSize = style[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE;
					
			    		var wid= (label.length ) * (fontSize * 0.625);
			    		geometry.width = wid;
			   			console.log(label.length+" "+wid+" "+geometry.width);
			    	}
				});*/
				
				var style = graph.getStylesheet().getDefaultEdgeStyle();
				//style["startArrow"] = "none";
				//style["endArrow"] = "none";
				
				keyHandler = new mxKeyHandler(graph);
				keyHandler.bindKey(46, function(evt){
					if (graph.isEnabled()){
						if(graph.getSelectionCell().isEdge())
							graph.removeCells();
					}
				});
				
				$.getJSON("NetworkTopology",function(data){
					if(data.status == "ok"){
						xml=data.graph;
						var doc = mxUtils.parseXml(xml);
						var decoder = new mxCodec(doc);
						decoder.decode(doc.documentElement, graph.getModel());
					}else{
						alert(data.details);
					}
				});
				
				
			}
		};
	
</script>

<script>
$(document).ready(function(){
	main(document.getElementById('graphContainer'));
	
	/*if (mxClient.IS_NS)
	{
	  mxEvent.addListener(graph.container, 'mousedown', function()
	  {
	    if (!graph.isEditing())
	    {
	      graph.container.setAttribute('tabindex', '-1');
	      graph.container.focus();
	    }
	  });
	}*/
}); 

$( "#sendChangesB" ).button().click(function( event ) {
	var encoder = new mxCodec();
	var result = encoder.encode(graph.getModel());

	var exml = mxUtils.getXml(result);
	console.log("TA-DAN!");
	console.log(exml);
	$.post("NetworkTopology",{"xml":exml},function(data,textStatus){
		   alert("data"+data);	
	},"xml");
	});
</script>
<style>
#graph-panel {
	margin: auto;
	text-align: center;
	width: 700px;
	height: 490px;
	padding: 10px;
	border: 2px solid gray;
}
;
</style>

<div id="command" style="float: left;">
	<button id="sendChangesB">SEND</button>
</div>

<div id="graph-panel">
	<div id="graphContainer" style="width:inherit; height:inherit; overflow:hidden;"></div>
</div>