<!-- Loads and initializes the library -->
<script type="text/javascript">
 var mxBasePath = "mxgraph";
</script>
<script type="text/javascript" src="mxgraph/js/mxClient.js"></script>

<script type="text/javascript">
		// Program starts here. Creates a sample graph in the
		// DOM node with the specified ID. This function is invoked
		// from the onLoad event handler of the document (see below).
		
		var graph;
		var keyHandler;
		var focusedCell;
		var root=0;
		function main(container)
		{
			// Checks if the browser is supported
			if (!mxClient.isBrowserSupported())
			{
				// Displays an error message if the browser is not supported.
				mxUtils.error('Browser is not supported!', 200, false);
			}
			else
			{	
				var xml;
				// Disables built-in context menu
				mxEvent.disableContextMenu(document.body);
				// Creates the graph inside the given container
				graph = new mxGraph(document.getElementById('graphContainer'));
				graph.setAllowDanglingEdges(false);
				graph.setCellsResizable(false);
				graph.setConnectable(true);
				graph.multigraph = false;
				graph.htmlLabels = true;
				graph.isCellEditable = function(cell){
					return false;
				};
				
				graph.minFitScale = null;
				graph.getView().updateStyle = true;
				
				var previous = graph.model.getStyle;
				
				graph.model.getStyle = function(cell)
				{
					if (cell != null)
					{
						var style = previous.apply(this, arguments);
						
						if (this.isEdge(cell))
						{
							if ( cell.getAttribute("isTree") == "true" ){
								var target = this.getTerminal(cell, false);

								if (target != null)
								{
									var state = graph.getView().getState(target);
									var targetStyle = (state != null) ? state.style : graph.getCellStyle(target);
									var fill = mxUtils.getValue(targetStyle, mxConstants.STYLE_FILLCOLOR);
									
									if (fill != null)
									{
										style += ';strokeWidth=4;strokeColor='+fill;
									}
								}
							}
						}else if (this.isVertex(cell))
						{
							var geometry = this.getGeometry(cell);
							
							if (geometry != null &&
								geometry.width > 80)
							{
								style += ';fillColor=green';
							}
						}
						
						return style;
					}
					
					return null;
				};
				
				//this sets the label to the dpid
				graph.convertValueToString = function(cell){
					if (mxUtils.isNode(cell.value)){
						if (cell.value.nodeName.toLowerCase() == ('switch')){
							var sw = "<div style=\" margin-top:15px\"><p>"+cell.getAttribute('ip')+"<br />"+cell.getAttribute('dpid')+"</p></div>";
							return sw;
						}
					}
					
					
					return ''; //returning empty string for edges and other stuff
				};
				
				//this will listen for the user trying to connect two switches.
				//if the link is non existent this handler will allow its creation, otherwise the user
				//event will be ignored
				mxConnectionHandlerInsertEdge = mxConnectionHandler.prototype.insertEdge;
				mxConnectionHandler.prototype.insertEdge = function(parent, id, value, source, target, style){
				    
				    //we get all outgoing edges from the target
				    var targetEdges = graph.getEdges(target,target.parent,false,true,true,false); 
				    
				    //now we check if an opposite edge exists
				    var result = false;
				    var i = 0;
				    while((result == false) && (i<targetEdges.length)){
				      if(targetEdges[i].target.id == source.id)
					result = true;
				      else
					i++;
				    }
				    
				    //if there isn't an opposite connection we insert the edge
				    if(result == false){
				    	var doc = mxUtils.createXmlDocument();
					    var linkEl = doc.createElement('link');
					    linkEl.setAttribute("srcDpid", source.value.getAttribute("dpid"));
					    linkEl.setAttribute("dstDpid", target.value.getAttribute("dpid"));
					    linkEl.setAttribute("srcPort", 0);
					    linkEl.setAttribute("dstPort", 0);
					    value = linkEl;
				      
					    return mxConnectionHandlerInsertEdge.apply(this, arguments);
				    }else
				      return null; //else we don't
				 };
				  
				keyHandler = new mxKeyHandler(graph);
				keyHandler.bindKey(46, function(evt){
					if(graph.getSelectionCell().isEdge())
							graph.removeCells();
					
				});
				  
				
				//setting style for vertexes
				var vStyle = graph.getStylesheet().getDefaultVertexStyle();
				vStyle[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_IMAGE;
				vStyle[mxConstants.STYLE_IMAGE] = "images/router.png";
				vStyle[mxConstants.STYLE_VERTICAL_LABEL_POSITION] = mxConstants.ALIGN_BOTTOM;
				vStyle[mxConstants.STYLE_FONTCOLOR] = "#0099CC";
				vStyle[mxConstants.STYLE_FONTSIZE] = 12;
				//vStyle[mxConstants.STYLE_IMAGE_BORDER]="#FF0000";
				//setting style for edges
				var eStyle = graph.getStylesheet().getDefaultEdgeStyle();
				eStyle[mxConstants.STYLE_ENDARROW] = "none";
				createMenu();
				getNetwork();
				document.getElementById("zoom").appendChild(mxUtils.button('+', function()
				{
					graph.zoomIn();
				})).className="btn";
				document.getElementById("zoom").appendChild(mxUtils.button('-', function()
				{
					graph.zoomOut();
				})).className="btn";
				
				
				$(".btn").css("margin",10);
				
			}
		}
		
		function createMenu(){
			// Configures automatic expand on mouseover
			graph.popupMenuHandler.autoExpand = true;
		    // Installs context menu
		    graph.setTooltips(true);
			graph.popupMenuHandler.factoryMethod = function(menu, cell, evt)
			{
				if (cell!=null && cell.isVertex()){
					menu.addItem('Root', null, function()
				    {
						if(root==0){
							root+=1;
							alert('Root Selected');
							// Creates a new overlay with an image and a tooltip
							var overlays=graph.getCellOverlays(cell);
						
							if (overlays!=null){
								graph.removeCellOverlays(cell);	
							}
							var overlay = new mxCellOverlay(
									new mxImage('images/crown.png', 26, 26),
									'Root');
							overlay.addListener(mxEvent.CLICK, function(sender, evt2)
									{
										mxUtils.alert('Root');
									});
														
							// Sets the overlay for the cell in the graph
							graph.addCellOverlay(cell, overlay);
							cell.setAttribute("type",ROOT_TYPE);
							var style=graph.getCellStyle(cell);
						}
						else {
							alert("Error root already selected");
						}
					
				    });
					
					menu.addItem('Leaf', null, function()
				    {
						if(cell.getAttribute("type")==ROOT_TYPE){
							root=0;
						}
						alert('Leaf Selected');
						// Creates a new overlay with an image and a tooltip
						var overlays=graph.getCellOverlays(cell);
						
						if (overlays!=null){
							graph.removeCellOverlays(cell);	
						}
					
						var overlay = new mxCellOverlay(new mxImage('images/leaf.png', 26, 26),
							'Leaf');
						overlay.addListener(mxEvent.CLICK, function(sender, evt2)
								{
									mxUtils.alert('Leaf');
								});
													
						// Sets the overlay for the cell in the graph
						graph.addCellOverlay(cell, overlay);
						
						cell.setAttribute("type",LEAF_TYPE);
				    });
					menu.addItem('Relay', null, function()
					{
						if(cell.getAttribute("type")==ROOT_TYPE){
							root=0;
						}
						alert('Relay Selected');
						// Creates a new overlay with an image and a tooltip
						var overlays=graph.getCellOverlays(cell);
						
						if (overlays!=null){
							graph.removeCellOverlays(cell);	
						}
					
						var overlay = new mxCellOverlay(
							new mxImage('images/relay.png', 26, 26),
							'Relay');
						overlay.addListener(mxEvent.CLICK, function(sender, evt2)
								{
									mxUtils.alert('Relay');
								});
													
						// Sets the overlay for the cell in the graph
						graph.addCellOverlay(cell, overlay);
											
						cell.setAttribute("type",RELAY_TYPE);
					});
				}
				else if(cell!=null && cell.isEdge()){
					menu.addItem('tree edge', null, function()
						    {
								alert('tree Selected');
						    });
					
					menu.addItem('redundancy', null, function()
				    {
						alert('redundancy');
				    });
					
				}
			};
		}
		
		function getNetwork(){
			$.getJSON("NetworkTopology",function(data){
				if(data.status == "ok"){
					xml=data.graph;
					var doc = mxUtils.parseXml(xml);
					var decoder = new mxCodec(doc);
					decoder.decode(doc.documentElement, graph.getModel());
					
					var layout = new mxCircleLayout(graph);
					layout.execute(graph.getDefaultParent());
				}else{
					//alert(data.details);
					showDialog("Errore",data.details);
				}
				$("#loadingMaskN").fadeOut("slow", function() {
		           // $("#graph-panel").fadeIn("slow");
		           
		           $("#graph-panel").fadeIn("slow");
		           $("#graph-panel").css("visibility","show");
		           $("#command").show();
		        });
				
			});
		}
	
</script>

<script>
$(document).ready(function(){
	main(document.getElementById('graphContainer'));
	
	/*if (mxClient.IS_NS)
	{
	  mxEvent.addListener(graph.container, 'mousedown', function()
	  {
	    if (!graph.isEditing())
	    {
	      graph.container.setAttribute('tabindex', '-1');
	      graph.container.focus();
	    }
	  });
	}*/
}); 

$( "#sendChangesB" ).button().click(function( event ) {
	var encoder = new mxCodec();
	var result = encoder.encode(graph.getModel());

	var exml = mxUtils.getXml(result);
	
	$.post("NetworkTopology",{"xml":exml},function(data){
		   if(data.status == "ok"){
			   graph.removeCells(graph.getChildVertices(graph.getDefaultParent()));
			   /*$.getJSON("NetworkTopology",function(data){
					if(data.status == "ok"){
						xml=data.graph;
						var doc = mxUtils.parseXml(xml);
						var decoder = new mxCodec(doc);
						decoder.decode(doc.documentElement, graph.getModel());
						
						var layout = new mxCircleLayout(graph);
						layout.execute(graph.getDefaultParent());
					}else{
						showDialog("Errore",data.details);
					}
				});*/
			   
				$('#loadingMaskN').show();
				$('#command').hide();
				$('#graph-panel').css("visibility","hidden");
				getNetwork();
		   }else
			   showDialog("Errore",data.details);
	});
	
	});
</script>
<style>
#graph-panel {
	margin: auto;
	text-align: center;
	width: 700px;
	height: 490px;
	padding: 10px;
	border: 2px solid gray;
};
</style>

<div id="content">
    <!-- Pre Loading... -->
	<div id="loadingMaskN" style="background: none repeat scroll 0% 0% rgb(255, 255, 255); text-align: center;margin: auto; width: inherit; height: inherit;">
		<img src="images/loading.gif" width="300px">
	</div>

    <div id="command" style="float: left;" hidden="true">
		<button id="sendChangesB">SEND</button>
	</div>
     
	<div id="graph-panel" style="visibility:hidden" >
		<div id="graphContainer" style="width:inherit; height:inherit; overflow:hidden;background: rgb(226,226,226); /* Old browsers */
	background: -moz-linear-gradient(-45deg, rgba(226,226,226,1) 0%, rgba(219,219,219,1) 50%, rgba(209,209,209,1) 51%, rgba(254,254,254,1) 100%); /* FF3.6+ */
	background: -webkit-gradient(linear, left top, right bottom, color-stop(0%,rgba(226,226,226,1)), color-stop(50%,rgba(219,219,219,1)), color-stop(51%,rgba(209,209,209,1)), color-stop(100%,rgba(254,254,254,1))); /* Chrome,Safari4+ */
	background: -webkit-linear-gradient(-45deg, rgba(226,226,226,1) 0%,rgba(219,219,219,1) 50%,rgba(209,209,209,1) 51%,rgba(254,254,254,1) 100%); /* Chrome10+,Safari5.1+ */"></div>
	</div>
	<div id="zoom" style="text-align:center; padding:10px">
	</div>
</div>
